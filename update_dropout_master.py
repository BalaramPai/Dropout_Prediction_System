# import pandas as pd
# import mysql.connector
#
# # ------------------------
# # CONFIG
# # ------------------------
# PREDICTIONS_CSV = "predictions.csv"  # generated by training script
# DB_HOST = "localhost"
# DB_USER = "root"
# DB_PASS = "baha1528"
# DB_NAME = "MiniProj"
# # ------------------------
#
# # 1) Load predictions
# df = pd.read_csv(PREDICTIONS_CSV)
#
# # 2) Ensure student_id exists
# if 'student_id' not in df.columns:
#     # sometimes index is saved as 'Unnamed: 0'
#     if 'Unnamed: 0' in df.columns:
#         df.rename(columns={'Unnamed: 0': 'student_id'}, inplace=True)
#     else:
#         # fallback: use index
#         df['student_id'] = df.index
#
# # 3) Filter only at-risk students
# df_risk = df[df['predicted_label'] == 1].copy()
# if df_risk.empty:
#     print("No at-risk students found. Exiting.")
#     exit()
#
# # 4) Connect to MySQL
# conn = mysql.connector.connect(
#     host=DB_HOST,
#     user=DB_USER,
#     password=DB_PASS,
#     database=DB_NAME
# )
# cursor = conn.cursor()
#
# # 5) Loop through df_risk and insert/update
# for _, row in df_risk.iterrows():
#     sql = """
#     INSERT INTO dropout_master
#     (student_id, student_name, failed_courses, attendance_count, attendance_rate, avg_grade, predicted_label, dropout_prob)
#     VALUES (%s,%s,%s,%s,%s,%s,%s,%s)
#     ON DUPLICATE KEY UPDATE
#         failed_courses=VALUES(failed_courses),
#         attendance_count=VALUES(attendance_count),
#         attendance_rate=VALUES(attendance_rate),
#         avg_grade=VALUES(avg_grade),
#         predicted_label=VALUES(predicted_label),
#         dropout_prob=VALUES(dropout_prob);
#     """
#     cursor.execute(sql, (
#         row["student_id"],
#         row.get("student_name", ""),         # fallback if missing
#         row.get("failed_courses", 0),
#         row.get("attendance_count", 0),
#         row.get("attendance_rate", 0.0),
#         row.get("avg_grade", 0.0),
#         row["predicted_label"],
#         row.get("dropout_prob", 0.0)
#     ))
#
# # 6) Commit and close
# conn.commit()
# cursor.close()
# conn.close()
#
# print(f"✅ {len(df_risk)} at-risk students inserted/updated in dropout_master")



# --- after model.fit(...) and predictions ---

import mysql.connector

# Predict probabilities and compute predicted_label
final_probs = model.predict_proba(X_proc)[:, 1]
predicted_label = (final_probs >= thresh).astype(int)

# Add predicted_label and dropout_prob to X_proc
X_proc['predicted_label'] = predicted_label
X_proc['dropout_prob'] = final_probs
X_proc['student_id'] = X.index  # keep student_id for DB join
if 'student_name' not in X_proc.columns and 'student_name' in features.columns:
    X_proc['student_name'] = features['student_name'].values

# Keep only at-risk students
df_risk = X_proc[X_proc['predicted_label'] == 1]

# --- DATABASE UPDATE ---
conn = mysql.connector.connect(
    host="localhost",
    user="root",
    password="baha1528",
    database="MiniProj"
)
cursor = conn.cursor()

for _, row in df_risk.iterrows():
    sql = """
    INSERT INTO dropout_master
    (student_id, student_name, failed_courses, attendance_count, attendance_rate, avg_grade, predicted_label, dropout_prob)
    VALUES (%s,%s,%s,%s,%s,%s,%s,%s)
    ON DUPLICATE KEY UPDATE
        failed_courses=VALUES(failed_courses),
        attendance_count=VALUES(attendance_count),
        attendance_rate=VALUES(attendance_rate),
        avg_grade=VALUES(avg_grade),
        predicted_label=VALUES(predicted_label),
        dropout_prob=VALUES(dropout_prob);
    """
    cursor.execute(sql, (
        row["student_id"],
        row["student_name"],
        row["failed_courses"],
        row["attendance_count"],
        row["attendance_rate"],
        row["avg_grade"],
        row["predicted_label"],
        row["dropout_prob"]
    ))

conn.commit()
cursor.close()
conn.close()
print(f"✅ {len(df_risk)} at-risk students inserted/updated in dropout_master")
